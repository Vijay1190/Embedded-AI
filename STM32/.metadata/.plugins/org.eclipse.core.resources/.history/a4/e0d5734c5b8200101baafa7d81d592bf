/* USER CODE BEGIN Header */
/**
  ******************************************************************************
  * @file           : main.c
  * @brief          : Main program body
  ******************************************************************************
  * @attention
  *
  * Copyright (c) 2025 STMicroelectronics.
  * All rights reserved.
  *
  * This software is licensed under terms that can be found in the LICENSE file
  * in the root directory of this software component.
  * If no LICENSE file comes with this software, it is provided AS-IS.
  *
  ******************************************************************************
  */
/* USER CODE END Header */
/* Includes ------------------------------------------------------------------*/
#include "main.h"

/* Private includes ----------------------------------------------------------*/
/* USER CODE BEGIN Includes */
#include "MY_LIS3DSH.h"
#include "stdio.h"

#define INPUT_SIZE   48
#define HIDDEN_SIZE  8
#define OUTPUT_SIZE  2

/* USER CODE END Includes */

/* Private typedef -----------------------------------------------------------*/
/* USER CODE BEGIN PTD */

/* USER CODE END PTD */

/* Private define ------------------------------------------------------------*/
/* USER CODE BEGIN PD */

/* USER CODE END PD */

/* Private macro -------------------------------------------------------------*/
/* USER CODE BEGIN PM */

/* USER CODE END PM */

/* Private variables ---------------------------------------------------------*/
SPI_HandleTypeDef hspi1;

/* USER CODE BEGIN PV */
/* Private variables ---------------------------------------------------------*/

/* USER CODE END PV */

/* Private function prototypes -----------------------------------------------*/
void SystemClock_Config(void);
static void MX_GPIO_Init(void);
static void MX_SPI1_Init(void);


float weights_0[HIDDEN_SIZE][INPUT_SIZE] = {
    {-0.009248f, -0.118557f, 0.208243f, -0.163616f, -0.060488f, -0.268575f, -0.023230f, -0.151569f, 0.264629f, -0.151983f, 0.036574f, -0.216678f, 0.357840f, 0.161347f, 0.147439f, -0.301130f, -0.144015f, -0.144806f, 0.189924f, 0.306377f, 0.243274f, -0.126550f, -0.277290f, -0.448562f, -0.418428f, 0.056340f, -0.033840f, -0.361544f, 0.093642f, 0.013097f, 0.428422f, -0.364270f, -0.074422f, -0.071462f, -0.128521f, -0.263121f, -0.079553f, 0.092966f, 0.211703f, -0.084975f, 0.172350f, -0.099468f, -0.160572f, 0.011061f, 0.065600f, -0.061778f, -0.029764f, -0.170664f},
    {0.384768f, -0.135495f, -0.016006f, 0.347942f, -0.144132f, -0.219928f, -0.046690f, 0.122077f, 0.171077f, 0.104701f, 0.396323f, 0.137047f, 0.066642f, 0.280293f, -0.058195f, -0.359640f, 0.362765f, -0.152319f, 0.039623f, 0.105440f, -0.116425f, -0.232434f, 0.246055f, 0.190452f, -0.254038f, -0.007870f, -0.109315f, -0.252314f, 0.258587f, -0.157954f, -0.064519f, 0.267690f, -0.058631f, 0.043144f, -0.213550f, -0.269866f, 0.334025f, -0.246975f, 0.135497f, 0.168581f, -0.320873f, -0.321203f, 0.183136f, -0.166291f, -0.155428f, 0.533877f, 0.058856f, 0.072174f},
    {-0.121144f, 0.053788f, -0.304576f, -0.010932f, -0.345424f, -0.115004f, 0.285119f, 0.006430f, -0.031238f, -0.035877f, 0.042796f, 0.299130f, -0.216345f, 0.259893f, -0.074611f, 0.050530f, -0.220957f, -0.191404f, -0.136651f, -0.178544f, 0.092465f, 0.351727f, 0.015293f, 0.362109f, 0.121798f, 0.028450f, -0.141901f, 0.131056f, -0.118409f, 0.065269f, -0.222709f, 0.426339f, -0.237870f, -0.112081f, 0.152006f, 0.132421f, 0.076533f, -0.332658f, -0.025455f, 0.266767f, -0.085367f, 0.134836f, 0.161583f, -0.258936f, 0.100799f, 0.018826f, 0.240000f, 0.123266f},
    {0.339630f, 0.148957f, 0.184222f, -0.111102f, 0.123493f, -0.182276f, -0.093422f, -0.084436f, 0.011906f, -0.146037f, 0.006075f, -0.339122f, 0.296695f, -0.161720f, 0.141399f, -0.330580f, -0.197337f, 0.227388f, 0.139939f, 0.028656f, -0.143564f, 0.196220f, 0.421478f, 0.267308f, -0.114202f, -0.280208f, 0.146955f, 0.081797f, -0.243636f, -0.160721f, -0.311347f, -0.180919f, 0.073943f, -0.060370f, 0.190864f, -0.203981f, -0.411017f, 0.062991f, 0.231828f, 0.469811f, 0.085244f, -0.219883f, 0.127716f, 0.436773f, -0.206916f, 0.050738f, -0.442110f, 0.120085f},
    {0.188799f, -0.283689f, 0.038470f, 0.211704f, 0.116398f, -0.049661f, -0.326955f, 0.150062f, 0.157345f, 0.297171f, -0.112237f, -0.203849f, 0.283246f, 0.197042f, 0.106618f, -0.138664f, -0.199510f, -0.016840f, 0.144372f, -0.129081f, -0.151998f, -0.273637f, -0.066409f, 0.295718f, 0.095097f, 0.026059f, -0.085781f, 0.264756f, 0.081669f, 0.296947f, 0.387264f, 0.147906f, 0.337967f, 0.220033f, -0.246322f, 0.096282f, -0.409989f, -0.376556f, -0.356582f, -0.237277f, 0.013432f, -0.010601f, -0.247410f, -0.214927f, 0.167955f, 0.330158f, 0.047960f, 0.034510f},
    {0.301355f, -0.131590f, -0.158630f, 0.338888f, -0.182594f, -0.109815f, 0.294967f, -0.186142f, 0.132974f, 0.058695f, -0.148682f, -0.133226f, 0.161351f, 0.300814f, 0.115827f, -0.133252f, 0.211691f, -0.105246f, -0.034439f, 0.222281f, 0.011963f, -0.175978f, 0.345224f, -0.154037f, -0.393880f, 0.114063f, -0.103951f, -0.217447f, -0.052645f, 0.108034f, -0.013868f, 0.047564f, -0.041440f, -0.273842f, 0.142536f, -0.103526f, -0.166144f, -0.213610f, -0.195054f, 0.065309f, -0.093937f, 0.102449f, 0.030862f, -0.328977f, -0.077958f, 0.148599f, -0.188262f, -0.177970f},
    {-0.333677f, -0.050790f, -0.005118f, -0.051967f, -0.083677f, -0.314397f, -0.035644f, -0.164411f, -0.067704f, 0.146315f, -0.010379f, -0.180889f, 0.442371f, -0.198329f, -0.012255f, 0.194497f, -0.585594f, -0.212406f, 0.226593f, -0.417777f, -0.018307f, 0.456047f, -0.187668f, 0.089061f, 0.318492f, -0.413544f, 0.082548f, 0.216797f, -0.285624f, -0.336448f, 0.043444f, -0.111849f, -0.067164f, 0.155661f, -0.006610f, 0.045288f, -0.008738f, -0.036603f, 0.081842f, -0.307240f, 0.235399f, -0.113751f, -0.204286f, 0.077886f, 0.043896f, -0.401047f, 0.246595f, 0.068605f},
    {-0.398826f, 0.065762f, 0.017678f, -0.518229f, -0.037466f, 0.181589f, -0.342687f, 0.100941f, 0.082637f, 0.101649f, 0.102711f, 0.190002f, -0.150738f, 0.239848f, -0.086516f, 0.174906f, -0.120503f, -0.133566f, 0.291571f, -0.364854f, -0.033506f, 0.254914f, -0.272895f, -0.223147f, 0.401583f, -0.111463f, -0.153783f, 0.253270f, -0.476645f, 0.091609f, 0.278618f, -0.316085f, -0.409646f, 0.304459f, 0.009391f, -0.025688f, 0.013671f, -0.303938f, 0.090723f, 0.329138f, -0.143573f, 0.145854f, -0.118298f, -0.057475f, -0.121266f, -0.077581f, -0.041994f, 0.009059f},
};
float bias_0[HIDDEN_SIZE] = {-0.092138f, -0.191203f, 0.074501f, 0.090687f, -0.043015f, -0.174053f, 0.118728f, -0.047329f};

// Layer 1: Dense (8 -> 2)
float weights_1[OUTPUT_SIZE][HIDDEN_SIZE] = {
    {0.769002f, -0.256216f, 0.477886f, 0.385358f, 0.613516f, -0.504618f, -0.124974f, 0.188920f},
    {-0.320030f, 0.157094f, -0.700852f, -0.488613f, -0.292140f, 0.277699f, 0.470617f, 0.412249f},
};
float bias_1[OUTPUT_SIZE] = {0.143582f, -0.143582f};

// --------------------------------------------------
// Activations
// --------------------------------------------------
float relu(float x) {
    return x > 0 ? x : 0;
}

void softmax(float *x, int size) {
    float max_val = x[0];
    for (int i = 1; i < size; i++)
        if (x[i] > max_val) max_val = x[i];
    float sum = 0.0f;
    for (int i = 0; i < size; i++) {
        x[i] = expf(x[i] - max_val);
        sum += x[i];
    }
    for (int i = 0; i < size; i++) {
        x[i] /= sum;
    }
}

/* USER CODE BEGIN PFP */
/* Private function prototypes -----------------------------------------------*/

/* USER CODE END PFP */

/* Private user code ---------------------------------------------------------*/
/* USER CODE BEGIN 0 */
LIS3DSH_DataScaled myData;

uint8_t drdyFlag=0;
/* USER CODE END 0 */

/**
  * @brief  The application entry point.
  * @retval int
  */


void neural_network_inference(float input[INPUT_SIZE], float output[OUTPUT_SIZE]) {
    float hidden[HIDDEN_SIZE];

    // Layer 0 forward
    for (int i = 0; i < HIDDEN_SIZE; i++) {
        float sum = bias_0[i];
        for (int j = 0; j < INPUT_SIZE; j++) {
            sum += input[j] * weights_0[i][j];
        }
        hidden[i] = relu(sum);
    }

    // Layer 1 forward
    for (int i = 0; i < OUTPUT_SIZE; i++) {
        float sum = bias_1[i];
        for (int j = 0; j < HIDDEN_SIZE; j++) {
            sum += hidden[j] * weights_1[i][j];
        }
        output[i] = sum;
    }

    // Apply softmax for probabilities
    softmax(output, OUTPUT_SIZE);
}


int main(void)
{
	float input[INPUT_SIZE] = {0};

  /* USER CODE BEGIN 1 */
	LIS3DSH_InitTypeDef myAccConfigDef;
  /* USER CODE END 1 */

  /* MCU Configuration--------------------------------------------------------*/

  /* Reset of all peripherals, Initializes the Flash interface and the Systick. */
  HAL_Init();

  /* USER CODE BEGIN Init */

  /* USER CODE END Init */

  /* Configure the system clock */
  SystemClock_Config();

  /* USER CODE BEGIN SysInit */

  /* USER CODE END SysInit */

  /* Initialize all configured peripherals */
  MX_GPIO_Init();
  MX_SPI1_Init();
  /* USER CODE BEGIN 2 */
	myAccConfigDef.dataRate = LIS3DSH_DATARATE_25;
	myAccConfigDef.fullScale = LIS3DSH_FULLSCALE_4;
	myAccConfigDef.antiAliasingBW = LIS3DSH_FILTER_BW_50;
	myAccConfigDef.enableAxes = LIS3DSH_XYZ_ENABLE;
	myAccConfigDef.interruptEnable = true;
	LIS3DSH_Init(&hspi1, &myAccConfigDef);

	LIS3DSH_X_calibrate(-1000.0, 980.0);
	LIS3DSH_Y_calibrate(-1020.0, 1040.0);
	LIS3DSH_Z_calibrate(-920.0, 1040.0);

  /* USER CODE END 2 */

  /* Infinite loop */
  /* USER CODE BEGIN WHILE */
  while (1)
  {
    /* USER CODE END WHILE */

    /* USER CODE BEGIN 3 */
		if(drdyFlag == 1)
		{
			drdyFlag = 0;
			myData = LIS3DSH_GetDataScaled();
			printf("X: %f, Y: %f, Z: %f\r\n", myData.x, myData.y, myData.z);
			HAL_GPIO_TogglePin(GPIOD, GPIO_PIN_12);
		}


  }
  /* USER CODE END 3 */
}

/**
  * @brief System Clock Configuration
  * @retval None
  */
void SystemClock_Config(void)
{
  RCC_OscInitTypeDef RCC_OscInitStruct = {0};
  RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};

  /** Configure the main internal regulator output voltage
  */
  __HAL_RCC_PWR_CLK_ENABLE();
  __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);

  /** Initializes the RCC Oscillators according to the specified parameters
  * in the RCC_OscInitTypeDef structure.
  */
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI;
  RCC_OscInitStruct.HSIState = RCC_HSI_ON;
  RCC_OscInitStruct.HSICalibrationValue = RCC_HSICALIBRATION_DEFAULT;
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSI;
  RCC_OscInitStruct.PLL.PLLM = 8;
  RCC_OscInitStruct.PLL.PLLN = 50;
  RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV4;
  RCC_OscInitStruct.PLL.PLLQ = 7;
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
  {
    Error_Handler();
  }

  /** Initializes the CPU, AHB and APB buses clocks
  */
  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
                              |RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV4;
  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV2;

  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_0) != HAL_OK)
  {
    Error_Handler();
  }
}

/**
  * @brief SPI1 Initialization Function
  * @param None
  * @retval None
  */
static void MX_SPI1_Init(void)
{

  /* USER CODE BEGIN SPI1_Init 0 */

  /* USER CODE END SPI1_Init 0 */

  /* USER CODE BEGIN SPI1_Init 1 */

  /* USER CODE END SPI1_Init 1 */
  /* SPI1 parameter configuration*/
  hspi1.Instance = SPI1;
  hspi1.Init.Mode = SPI_MODE_MASTER;
  hspi1.Init.Direction = SPI_DIRECTION_2LINES;
  hspi1.Init.DataSize = SPI_DATASIZE_8BIT;
  hspi1.Init.CLKPolarity = SPI_POLARITY_LOW;
  hspi1.Init.CLKPhase = SPI_PHASE_1EDGE;
  hspi1.Init.NSS = SPI_NSS_SOFT;
  hspi1.Init.BaudRatePrescaler = SPI_BAUDRATEPRESCALER_8;
  hspi1.Init.FirstBit = SPI_FIRSTBIT_MSB;
  hspi1.Init.TIMode = SPI_TIMODE_DISABLE;
  hspi1.Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE;
  hspi1.Init.CRCPolynomial = 10;
  if (HAL_SPI_Init(&hspi1) != HAL_OK)
  {
    Error_Handler();
  }
  /* USER CODE BEGIN SPI1_Init 2 */

  /* USER CODE END SPI1_Init 2 */

}

/**
  * @brief GPIO Initialization Function
  * @param None
  * @retval None
  */
static void MX_GPIO_Init(void)
{
  GPIO_InitTypeDef GPIO_InitStruct = {0};
  /* USER CODE BEGIN MX_GPIO_Init_1 */

  /* USER CODE END MX_GPIO_Init_1 */

  /* GPIO Ports Clock Enable */
  __HAL_RCC_GPIOE_CLK_ENABLE();
  __HAL_RCC_GPIOA_CLK_ENABLE();
  __HAL_RCC_GPIOD_CLK_ENABLE();

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(MEMS_CS_GPIO_Port, MEMS_CS_Pin, GPIO_PIN_RESET);

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(GPIOD, GPIO_PIN_12|GPIO_PIN_13|GPIO_PIN_14|GPIO_PIN_15, GPIO_PIN_RESET);

  /*Configure GPIO pin : MEMS_CS_Pin */
  GPIO_InitStruct.Pin = MEMS_CS_Pin;
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
  HAL_GPIO_Init(MEMS_CS_GPIO_Port, &GPIO_InitStruct);

  /*Configure GPIO pins : PD12 PD13 PD14 PD15 */
  GPIO_InitStruct.Pin = GPIO_PIN_12|GPIO_PIN_13|GPIO_PIN_14|GPIO_PIN_15;
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
  HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);

  /*Configure GPIO pin : PE0 */
  GPIO_InitStruct.Pin = GPIO_PIN_0;
  GPIO_InitStruct.Mode = GPIO_MODE_IT_RISING;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  HAL_GPIO_Init(GPIOE, &GPIO_InitStruct);

  /* EXTI interrupt init*/
  HAL_NVIC_SetPriority(EXTI0_IRQn, 0, 0);
  HAL_NVIC_EnableIRQ(EXTI0_IRQn);

  /* USER CODE BEGIN MX_GPIO_Init_2 */

  /* USER CODE END MX_GPIO_Init_2 */
}

/* USER CODE BEGIN 4 */
void HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin)
{
  /* Prevent unused argument(s) compilation warning */
  UNUSED(GPIO_Pin);
  /* NOTE: This function Should not be modified, when the callback is needed,
           the HAL_GPIO_EXTI_Callback could be implemented in the user file
   */

	drdyFlag = 1;
	HAL_GPIO_TogglePin(GPIOD, GPIO_PIN_13);
}
/* USER CODE END 4 */

/**
  * @brief  This function is executed in case of error occurrence.
  * @retval None
  */
void Error_Handler(void)
{
  /* USER CODE BEGIN Error_Handler_Debug */
  /* User can add his own implementation to report the HAL error return state */
  while(1)
  {
  }
  /* USER CODE END Error_Handler_Debug */
}
#ifdef USE_FULL_ASSERT
/**
  * @brief  Reports the name of the source file and the source line number
  *         where the assert_param error has occurred.
  * @param  file: pointer to the source file name
  * @param  line: assert_param error line source number
  * @retval None
  */
void assert_failed(uint8_t *file, uint32_t line)
{
  /* USER CODE BEGIN 6 */
  /* User can add his own implementation to report the file name and line number,
    ex: printf("Wrong parameters value: file %s on line %d\r\n", file, line) */
  /* USER CODE END 6 */
}
#endif /* USE_FULL_ASSERT */
